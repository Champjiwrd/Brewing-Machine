{"ast":null,"code":"/* eslint-disable vars-on-top, no-var, prefer-template */\nvar isRegExp = require('lodash/isRegExp');\n\nvar escapeRegExp = require('lodash/escapeRegExp');\n\nvar isString = require('lodash/isString');\n\nvar flatten = require('lodash/flatten');\n/**\r\n * Given a string, replace every substring that is matched by the `match` regex\r\n * with the result of calling `fn` on matched substring. The result will be an\r\n * array with all odd indexed elements containing the replacements. The primary\r\n * use case is similar to using String.prototype.replace except for React.\r\n *\r\n * React will happily render an array as children of a react element, which\r\n * makes this approach very useful for tasks like surrounding certain text\r\n * within a string with react elements.\r\n *\r\n * Example:\r\n * matchReplace(\r\n *   'Emphasize all phone numbers like 884-555-4443.',\r\n *   /([\\d|-]+)/g,\r\n *   (number, i) => <strong key={i}>{number}</strong>\r\n * );\r\n * // => ['Emphasize all phone numbers like ', <strong>884-555-4443</strong>, '.'\r\n *\r\n * @param {string} str\r\n * @param {regexp|str} match Must contain a matching group\r\n * @param {function} fn\r\n * @return {array}\r\n */\n\n\nfunction replaceString(str, match, fn) {\n  var curCharStart = 0;\n  var curCharLen = 0;\n\n  if (str === '') {\n    return str;\n  } else if (!str || !isString(str)) {\n    throw new TypeError('First argument to react-string-replace#replaceString must be a string');\n  }\n\n  var re = match;\n\n  if (!isRegExp(re)) {\n    re = new RegExp('(' + escapeRegExp(re) + ')', 'gi');\n  }\n\n  var result = str.split(re); // Apply fn to all odd elements\n\n  for (var i = 1, length = result.length; i < length; i += 2) {\n    curCharLen = result[i].length;\n    curCharStart += result[i - 1].length;\n    result[i] = fn(result[i], i, curCharStart);\n    curCharStart += curCharLen;\n  }\n\n  return result;\n}\n\nmodule.exports = function reactStringReplace(source, match, fn) {\n  if (!Array.isArray(source)) source = [source];\n  return flatten(source.map(function (x) {\n    return isString(x) ? replaceString(x, match, fn) : x;\n  }));\n};","map":{"version":3,"sources":["D:/CE03/TOC/Assign/react/Brewing-Machine/node_modules/react-string-replace/index.js"],"names":["isRegExp","require","escapeRegExp","isString","flatten","replaceString","str","match","fn","curCharStart","curCharLen","TypeError","re","RegExp","result","split","i","length","module","exports","reactStringReplace","source","Array","isArray","map","x"],"mappings":"AAAA;AACA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,iBAAD,CAAtB;;AACA,IAAIC,YAAY,GAAGD,OAAO,CAAC,qBAAD,CAA1B;;AACA,IAAIE,QAAQ,GAAGF,OAAO,CAAC,iBAAD,CAAtB;;AACA,IAAIG,OAAO,GAAGH,OAAO,CAAC,gBAAD,CAArB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA,SAASI,aAAT,CAAuBC,GAAvB,EAA4BC,KAA5B,EAAmCC,EAAnC,EAAuC;AACrC,MAAIC,YAAY,GAAG,CAAnB;AACA,MAAIC,UAAU,GAAG,CAAjB;;AAEA,MAAIJ,GAAG,KAAK,EAAZ,EAAgB;AACd,WAAOA,GAAP;AACD,GAFD,MAEO,IAAI,CAACA,GAAD,IAAQ,CAACH,QAAQ,CAACG,GAAD,CAArB,EAA4B;AACjC,UAAM,IAAIK,SAAJ,CAAc,uEAAd,CAAN;AACD;;AAED,MAAIC,EAAE,GAAGL,KAAT;;AAEA,MAAI,CAACP,QAAQ,CAACY,EAAD,CAAb,EAAmB;AACjBA,IAAAA,EAAE,GAAG,IAAIC,MAAJ,CAAW,MAAMX,YAAY,CAACU,EAAD,CAAlB,GAAyB,GAApC,EAAyC,IAAzC,CAAL;AACD;;AAED,MAAIE,MAAM,GAAGR,GAAG,CAACS,KAAJ,CAAUH,EAAV,CAAb,CAhBqC,CAkBrC;;AACA,OAAK,IAAII,CAAC,GAAG,CAAR,EAAWC,MAAM,GAAGH,MAAM,CAACG,MAAhC,EAAwCD,CAAC,GAAGC,MAA5C,EAAoDD,CAAC,IAAI,CAAzD,EAA4D;AAC1DN,IAAAA,UAAU,GAAGI,MAAM,CAACE,CAAD,CAAN,CAAUC,MAAvB;AACAR,IAAAA,YAAY,IAAIK,MAAM,CAACE,CAAC,GAAG,CAAL,CAAN,CAAcC,MAA9B;AACAH,IAAAA,MAAM,CAACE,CAAD,CAAN,GAAYR,EAAE,CAACM,MAAM,CAACE,CAAD,CAAP,EAAYA,CAAZ,EAAeP,YAAf,CAAd;AACAA,IAAAA,YAAY,IAAIC,UAAhB;AACD;;AAED,SAAOI,MAAP;AACD;;AAEDI,MAAM,CAACC,OAAP,GAAiB,SAASC,kBAAT,CAA4BC,MAA5B,EAAoCd,KAApC,EAA2CC,EAA3C,EAA+C;AAC9D,MAAI,CAACc,KAAK,CAACC,OAAN,CAAcF,MAAd,CAAL,EAA4BA,MAAM,GAAG,CAACA,MAAD,CAAT;AAE5B,SAAOjB,OAAO,CAACiB,MAAM,CAACG,GAAP,CAAW,UAASC,CAAT,EAAY;AACpC,WAAOtB,QAAQ,CAACsB,CAAD,CAAR,GAAcpB,aAAa,CAACoB,CAAD,EAAIlB,KAAJ,EAAWC,EAAX,CAA3B,GAA4CiB,CAAnD;AACD,GAFc,CAAD,CAAd;AAGD,CAND","sourcesContent":["/* eslint-disable vars-on-top, no-var, prefer-template */\r\nvar isRegExp = require('lodash/isRegExp');\r\nvar escapeRegExp = require('lodash/escapeRegExp');\r\nvar isString = require('lodash/isString');\r\nvar flatten = require('lodash/flatten');\r\n\r\n/**\r\n * Given a string, replace every substring that is matched by the `match` regex\r\n * with the result of calling `fn` on matched substring. The result will be an\r\n * array with all odd indexed elements containing the replacements. The primary\r\n * use case is similar to using String.prototype.replace except for React.\r\n *\r\n * React will happily render an array as children of a react element, which\r\n * makes this approach very useful for tasks like surrounding certain text\r\n * within a string with react elements.\r\n *\r\n * Example:\r\n * matchReplace(\r\n *   'Emphasize all phone numbers like 884-555-4443.',\r\n *   /([\\d|-]+)/g,\r\n *   (number, i) => <strong key={i}>{number}</strong>\r\n * );\r\n * // => ['Emphasize all phone numbers like ', <strong>884-555-4443</strong>, '.'\r\n *\r\n * @param {string} str\r\n * @param {regexp|str} match Must contain a matching group\r\n * @param {function} fn\r\n * @return {array}\r\n */\r\nfunction replaceString(str, match, fn) {\r\n  var curCharStart = 0;\r\n  var curCharLen = 0;\r\n\r\n  if (str === '') {\r\n    return str;\r\n  } else if (!str || !isString(str)) {\r\n    throw new TypeError('First argument to react-string-replace#replaceString must be a string');\r\n  }\r\n\r\n  var re = match;\r\n\r\n  if (!isRegExp(re)) {\r\n    re = new RegExp('(' + escapeRegExp(re) + ')', 'gi');\r\n  }\r\n\r\n  var result = str.split(re);\r\n\r\n  // Apply fn to all odd elements\r\n  for (var i = 1, length = result.length; i < length; i += 2) {\r\n    curCharLen = result[i].length;\r\n    curCharStart += result[i - 1].length;\r\n    result[i] = fn(result[i], i, curCharStart);\r\n    curCharStart += curCharLen;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports = function reactStringReplace(source, match, fn) {\r\n  if (!Array.isArray(source)) source = [source];\r\n\r\n  return flatten(source.map(function(x) {\r\n    return isString(x) ? replaceString(x, match, fn) : x;\r\n  }));\r\n};\r\n"]},"metadata":{},"sourceType":"script"}